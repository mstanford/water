// ------------------------------------------------------------------------------
// 
// Copyright (c) 2008 Swampware, Inc.
// 
// Permission is hereby granted, free of charge, to any person
// obtaining a copy of this software and associated documentation
// files (the "Software"), to deal in the Software without
// restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following
// conditions:
// 
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
// OTHER DEALINGS IN THE SOFTWARE.
// 
// ------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Text;

namespace Bamboo.Parsing.Generators.CSharp
{
	public class EvaluatorGenerator
	{

		public static void Generate(string name, string nspace, Bamboo.Parsing.Grammars.Grammar grammar, System.IO.TextWriter writer)
		{
			writer.WriteLine("//");
			writer.WriteLine("// AUTOGENERATED " + System.DateTime.Now + "");
			writer.WriteLine("//");
			writer.WriteLine("using System;");
			writer.WriteLine("");
			writer.WriteLine("namespace " + nspace + "");
			writer.WriteLine("{");
			writer.WriteLine("	public abstract class " + name + "Evaluator");
			writer.WriteLine("	{");
			writer.WriteLine("");
			writer.WriteLine("		public " + name + "Evaluator()");
			writer.WriteLine("		{");
			writer.WriteLine("		}");
			writer.WriteLine("");
			writer.WriteLine("		public object Evaluate(" + name + "Node node)");
			writer.WriteLine("		{");
			writer.WriteLine("			switch (node.Type)");
			writer.WriteLine("			{");
			foreach (string nonterminal in grammar.Nonterminals)
			{
				writer.WriteLine("				case " + name + "NodeType." + nonterminal + ":");
				writer.WriteLine("					{");
				foreach (Bamboo.Parsing.Grammars.Production production in GetProductions(nonterminal, grammar))
				{
					if (production.Expression is Bamboo.Parsing.Grammars.Concatenation)
					{
						Bamboo.Parsing.Grammars.Concatenation concatenation = (Bamboo.Parsing.Grammars.Concatenation)production.Expression;

						string tag = "";

						writer.Write("						if(");
						writer.Write("node.Nodes.Count == " + concatenation.Expressions.Count);
						int i = 0;
						foreach (Bamboo.Parsing.Grammars.Symbol symbol in concatenation.Expressions)
						{
							tag += symbol.Token;
							writer.Write(" && node.Nodes[" + i + "].Type == " + name + "NodeType." + symbol.Token + "");
							i++;
						}

						writer.WriteLine(")");
						writer.WriteLine("						{");
						writer.WriteLine("							return Evaluate" + tag + "(node);");
						writer.WriteLine("						}");
					}
					else if (production.Expression is Bamboo.Parsing.Grammars.Symbol)
					{
						Bamboo.Parsing.Grammars.Symbol symbol = (Bamboo.Parsing.Grammars.Symbol)production.Expression;

						if (!symbol.Token.Equals("EPSILON"))
						{
							string tag = symbol.Token;

							writer.Write("						if(");
							writer.Write("node.Nodes.Count == 1");
							writer.Write(" && node.Nodes[0].Type == " + name + "NodeType." + symbol.Token + "");
							writer.WriteLine(")");
							writer.WriteLine("						{");
							if (grammar.Terminals.Contains(symbol.Token))
							{
								writer.WriteLine("							return Evaluate" + tag + "(node.Nodes[0].Value);");
							}
							else
							{
								writer.WriteLine("							return Evaluate" + tag + "(node.Nodes[0]);");
							}
							writer.WriteLine("						}");
						}
					}
					else
					{
						throw new System.Exception("Invalid expression.");
					}
				}
				writer.WriteLine("						throw new System.Exception(\"Invalid expression.\");");
				writer.WriteLine("					}");
			}
			foreach (string terminal in grammar.Terminals)
			{
				if (!terminal.Equals("EPSILON"))
				{
					writer.WriteLine("				case " + name + "NodeType." + terminal + ":");
					writer.WriteLine("					{");
					writer.WriteLine("						return Evaluate" + terminal + "(node.Value);");
					writer.WriteLine("					}");
				}
			}
			writer.WriteLine("				default:");
			writer.WriteLine("					{");
			writer.WriteLine("						throw new System.Exception(\"Invalid expression.\");");
			writer.WriteLine("					}");
			writer.WriteLine("			}");
			writer.WriteLine("		}");
			writer.WriteLine("");
			Surf.Set functions = new Surf.Set();
			functions.Define("EPSILON", "EPSILON");
			foreach (string nonterminal in grammar.Nonterminals)
			{
				foreach (Bamboo.Parsing.Grammars.Production production in GetProductions(nonterminal, grammar))
				{
					string tag = "";

					if (production.Expression is Bamboo.Parsing.Grammars.Concatenation)
					{
						Bamboo.Parsing.Grammars.Concatenation concatenation = (Bamboo.Parsing.Grammars.Concatenation)production.Expression;

						foreach (Bamboo.Parsing.Grammars.Symbol symbol in concatenation.Expressions)
						{
							tag += symbol.Token;
						}
						if (!functions.IsDefined(tag))
						{
							writer.WriteLine("		protected virtual object Evaluate" + tag + "(" + name + "Node node)");
							writer.WriteLine("		{");
							writer.WriteLine("			throw new System.Exception(\"Implement.\");");
							writer.WriteLine("		}");
							writer.WriteLine("");
							functions.Define(tag, tag);
						}
					}
					else if (production.Expression is Bamboo.Parsing.Grammars.Symbol)
					{
						Bamboo.Parsing.Grammars.Symbol symbol = (Bamboo.Parsing.Grammars.Symbol)production.Expression;

						tag += symbol.Token;
						if (!functions.IsDefined(tag))
						{
							if (grammar.Terminals.Contains(symbol.Token))
							{
								writer.WriteLine("		protected virtual object Evaluate" + tag + "(string value)");
							}
							else
							{
								writer.WriteLine("		protected virtual object Evaluate" + tag + "(" + name + "Node node)");
							}
							writer.WriteLine("		{");
							writer.WriteLine("			throw new System.Exception(\"Implement.\");");
							writer.WriteLine("		}");
							writer.WriteLine("");
							functions.Define(tag, tag);
						}
					}
					else
					{
						throw new System.Exception("Invalid expression.");
					}
				}
			}
			foreach (string terminal in grammar.Terminals)
			{
				if (!functions.IsDefined(terminal))
				{
					writer.WriteLine("		protected virtual object Evaluate" + terminal + "(string value)");
					writer.WriteLine("		{");
					writer.WriteLine("			throw new System.Exception(\"Implement.\");");
					writer.WriteLine("		}");
					writer.WriteLine("");
					functions.Define(terminal, terminal);
				}
			}
			writer.WriteLine("	}");
			writer.WriteLine("}");
		}

		private static List<Bamboo.Parsing.Grammars.Production> GetProductions(string nonterminal, Bamboo.Parsing.Grammars.Grammar grammar)
		{
			List<Bamboo.Parsing.Grammars.Production> productions = new List<Bamboo.Parsing.Grammars.Production>();
			foreach (Bamboo.Parsing.Grammars.Production production in grammar.Productions)
			{
				if (production.Nonterminal.Equals(nonterminal))
				{
					productions.Add(production);
				}
			}
			return productions;
		}

		private EvaluatorGenerator()
		{
		}

	}
}
